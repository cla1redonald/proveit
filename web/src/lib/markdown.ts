// Client-side utility — no server imports

import type { ValidationSession } from "@/types";

const KILL_SIGNAL_LABEL: Record<string, string> = {
  tarpit: "Tarpit — multiple failed attempts in this space",
  saturation: "Saturated market — too many active competitors",
  no_switching: "No switching evidence — people complain but don't change",
  no_willingness_to_pay: "No willingness to pay — competitors all free, no paid tier survives",
};

/**
 * Strips tool markup that the model sometimes includes literally in its text
 * output alongside actual API tool calls. Handles both formats:
 * - <tool_call>/<tool_response> (older format)
 * - <function_calls>/<function_response>/<invoke> (newer format)
 */
export function cleanAssistantText(text: string): string {
  return text
    .replace(/<tool_call>[\s\S]*?<\/tool_call>/g, "")
    .replace(/<tool_response>[\s\S]*?<\/tool_response>/g, "")
    .replace(/<function_calls>[\s\S]*?<\/function_calls>/g, "")
    .replace(/<function_response>[\s\S]*?<\/function_response>/g, "")
    .replace(/<invoke[\s\S]*?<\/invoke>/g, "")
    .replace(/\n{3,}/g, "\n\n")
    .trim();
}

export function generateDiscoveryMarkdown(session: ValidationSession): string {
  const date = new Date(session.updatedAt).toLocaleDateString("en-GB", {
    year: "numeric",
    month: "long",
    day: "numeric",
  });

  const score = (n: number | null) => (n !== null ? `${n}/10` : "—");

  const lines: string[] = [];

  // ── Header ──────────────────────────────────────────────────────────────────
  lines.push(`# ProveIt Validation Report`);
  lines.push(``);
  lines.push(`**Idea:** ${session.ideaSummary}`);
  lines.push(`**Date:** ${date}`);
  lines.push(``);

  // ── Confidence Scores ────────────────────────────────────────────────────────
  lines.push(`## Confidence Scores`);
  lines.push(``);
  lines.push(`| Dimension | Score |`);
  lines.push(`|-----------|-------|`);
  lines.push(`| Desirability | ${score(session.scores.desirability)} |`);
  lines.push(`| Viability | ${score(session.scores.viability)} |`);
  lines.push(`| Feasibility | ${score(session.scores.feasibility)} |`);
  lines.push(``);

  // ── Kill Signals ─────────────────────────────────────────────────────────────
  if (session.killSignals.length > 0) {
    lines.push(`## ⚠️ Kill Signals`);
    lines.push(``);
    for (const ks of session.killSignals) {
      const label = KILL_SIGNAL_LABEL[ks.type] ?? ks.type;
      lines.push(`**${label}**`);
      lines.push(``);
      lines.push(ks.evidence);
      lines.push(``);
    }
  }

  // ── Conversation ──────────────────────────────────────────────────────────────
  lines.push(`## Discovery & Research`);
  lines.push(``);

  for (const msg of session.messages) {
    if (msg.role === "user") {
      lines.push(`**You:** ${msg.content}`);
      lines.push(``);
    } else {
      const cleaned = cleanAssistantText(msg.content);
      if (cleaned.length > 0) {
        lines.push(`**ProveIt:**`);
        lines.push(``);
        lines.push(cleaned);
        lines.push(``);
      }
    }
  }

  lines.push(`---`);
  lines.push(`*Generated by ProveIt on ${date}*`);

  return lines.join("\n");
}
